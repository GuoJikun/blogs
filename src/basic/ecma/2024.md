# ECMA 2024(ES15) æ–°ç‰¹æ€§

## ECMAScript 2024 ä¸»è¦åŒ…å«å†…å®¹ <Badge text="WIP" type="warning" />

> ECMAScript 2024 äº 2024 å¹´ 6 æœˆ 22 æ—¥è·å¾— ECMA International çš„æ‰¹å‡†ã€‚<br>
> ECMAScript æ˜¯æ ‡å‡†åŒ–çš„ JavaScript è¯­è¨€ï¼Œäº 1997 å¹´å‘å¸ƒäº†ç¬¬ä¸€ç‰ˆï¼Œç°å·²å‘å±•æˆä¸ºä¸–ç•Œä¸Šä½¿ç”¨æœ€å¹¿æ³›çš„é€šç”¨ç¼–ç¨‹è¯­è¨€ä¹‹ä¸€ã€‚<br>
> æœ¬ Ecma æ ‡å‡†å®šä¹‰äº† ECMAScript 2024 Languageï¼Œæ˜¯ ECMAScript è¯­è¨€è§„èŒƒçš„ç¬¬ 15 ç‰ˆã€‚

## æ ¼å¼æ­£ç¡®çš„ Unicode å­—ç¬¦ä¸²

æ­¤åŠŸèƒ½æ—¨åœ¨æ”¹è¿› JavaScript å¤„ç† Unicode å­—ç¬¦ä¸²çš„æ–¹å¼ã€‚

```js
const str1 = "Bhaiya-G-Smile\uD83D\uDE00";
const str2 = "No\uDC00Smile";

console.log(str1.toWellFormed());
// "Bhaiya-G-SmileğŸ˜€"
console.log(str2.toWellFormed());
// "Noï¿½Smile"
```

## å¼‚æ­¥çš„åŸå­ç­‰å¾…

æ­¤æ“ä½œä»…é€‚ç”¨äºæŸ¥çœ‹ Â `SharedArrayBuffer`Â  çš„ Â `Int32Array`Â  æˆ– Â `BigInt64Array`Â ã€‚

```js
const sab = new SharedArrayBuffer(1024);
const int32 = new Int32Array(sab);
```

è¯»å–çº¿ç¨‹æ­£åœ¨ç¡çœ å¹¶ç­‰å¾…ä½ç½® `0`ï¼Œè¯¥ä½ç½®é¢„è®¡ä¸º Â `Avyukt`Â ã€‚Â `result.value`Â  å°†æ˜¯ä¸€ä¸ª `Promise`ã€‚

```js
const result = Atomics.waitAsync(int32, 0, "Avyukt", 1000);
// { async: true, value: Promise {<pending>} }
```

åœ¨è¯»å–çº¿ç¨‹æˆ–å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ï¼Œè°ƒç”¨å†…å­˜ä½ç½® 0ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨ Â `"ok"`Â  è§£æ Promiseã€‚

```js
Atomics.notify(int32, 0);
// { async: true, value: Promise {<fulfilled>: 'ok'} }
```

## æ­£åˆ™è¡¨è¾¾å¼çš„ v æ ‡å¿—

è¿™æ˜¯ä¸€ä¸ªä¸ä¼ ç»Ÿ `u`ï¼ˆUnicode æ¨¡å¼ï¼‰ç›¸å…³ä½†æ›´å¼ºå¤§çš„æ¨¡å¼ã€‚å®ƒä¸»è¦è§£å†³äº† Unicode æ­£åˆ™è¡¨è¾¾å¼åœ¨å¤„ç†å±æ€§ã€é›†åˆå’Œå­—ç¬¦åŒ¹é…æ—¶çš„æ­§ä¹‰å’Œå±€é™æ€§ã€‚

ç®€å•æ¥è¯´ï¼Œ`v` æ ‡å¿—æä¾›äº†ï¼š

### å­—ç¬¦ç±»é›†åˆçš„æ”¹è¿›

å…è®¸åœ¨å­—ç¬¦ç±»ä¸­ä½¿ç”¨é›†åˆè¿ç®—ï¼ˆå¹¶é›†ã€äº¤é›†ã€å·®é›†ï¼‰ã€‚

```js
// [\p{Letter}] ä¸ [\p{Number}] çš„äº¤é›†ï¼šå³åŒæ—¶æ˜¯å­—æ¯å’Œæ•°å­—çš„å­—ç¬¦
const regex = /^[\p{Letter}&&\p{Number}]$/v;

console.log(regex.test("A")); // false
console.log(regex.test("1")); // false
console.log(regex.test("Ù£")); // true (é˜¿æ‹‰ä¼¯-å°åº¦æ•°å­— Ù£ï¼ŒåŒæ—¶å…·å¤‡æ•°å€¼å±æ€§å’Œå­—æ¯å±æ€§)
```

### ç®€åŒ–çš„å±æ€§åŒ¹é…

åœ¨ `v` æ¨¡å¼ä¸‹ï¼ŒUnicode å±æ€§åŒ¹é…æ›´ä¸¥æ ¼ã€æ›´ä¸€è‡´ã€‚

```js
const letter = /^\p{Letter}+$/v;

console.log(letter.test("Hello")); // true
console.log(letter.test("123"));   // false
```

### é¿å…æ­§ä¹‰

åœ¨ `u` æ¨¡å¼ä¸­ï¼Œæœ‰äº›è¡¨è¾¾å¼ä¼šå› ä¸º Unicode è¾¹ç•Œé—®é¢˜è€Œå¯¼è‡´æ„æ–™ä¹‹å¤–çš„åŒ¹é…è¡Œä¸ºï¼Œè€Œ `v` æ¨¡å¼è§£å†³äº†è¿™äº›é—®é¢˜ã€‚

```js
// u æ¨¡å¼ä¸‹å¯èƒ½äº§ç”Ÿæ··æ·†
console.log(/\p{General_Category=Letter}/u.test("A")); // true
// v æ¨¡å¼ä¸‹æ›´è§„èŒƒ
console.log(/\p{General_Category=Letter}/v.test("A")); // true
```

é›†åˆè¿ç®—ç¤ºä¾‹

```js
// å¹¶é›†ï¼ˆunionï¼‰ï¼š
const regex = /^[\p{Letter}||\p{Number}]+$/v;
console.log(regex.test("Hello123")); // true
console.log(regex.test("!?"));       // false


// å·®é›†ï¼ˆsubtractionï¼‰ï¼š
// åŒ¹é…æ‰€æœ‰å­—æ¯ï¼Œä½†æ’é™¤ ASCII
const regex = /^[\p{Letter}--\p{ASCII}]+$/v;
console.log(regex.test("Ã±")); // true
console.log(regex.test("A")); // false


// äº¤é›†ï¼ˆintersectionï¼‰ï¼š
// åŒæ—¶å±äº Letter å’Œ Uppercase çš„å­—ç¬¦
const regex = /^[\p{Letter}&&\p{Uppercase_Letter}]+$/v;
console.log(regex.test("A")); // true
console.log(regex.test("a")); // false
```

`v` æ ‡å¿—çš„å‡ºç°è®©æ­£åˆ™è¡¨è¾¾å¼åœ¨å¤„ç† Unicode æ–‡æœ¬ã€å›½é™…åŒ–ã€é›†åˆæ“ä½œ æ—¶æ›´ç›´è§‚ã€æ›´å¼ºå¤§ã€‚å®ƒå¤§å¤§ç®€åŒ–äº†è¿‡å»ä¾èµ–å¤æ‚æ¨¡å¼æ‰èƒ½å®Œæˆçš„ä»»åŠ¡ï¼Œå¯¹äºéœ€è¦å¤„ç†å¤šè¯­è¨€æ–‡æœ¬çš„å¼€å‘è€…æ¥è¯´éå¸¸å®ç”¨ã€‚

## å¯è°ƒæ•´å¤§å°å’Œå¯å¢é•¿ Â `ArrayBuffer`

`ArrayBuffer`Â  å¯ç”¨äº†äºŒè¿›åˆ¶æ•°æ®çš„å†…å­˜å¤„ç†ï¼Œå¹¶å–å¾—äº†å·¨å¤§çš„æˆåŠŸã€‚
æ­¤ææ¡ˆæ‰©å±•äº† Â `ArrayBuffer`Â  æ„é€ å‡½æ•°ä»¥é‡‡ç”¨é¢å¤–çš„æœ€å¤§é•¿åº¦ï¼Œä»¥å…è®¸ç¼“å†²åŒºå°±åœ°å¢é•¿å’Œç¼©å°ã€‚
åŒæ ·ï¼ŒÂ `SharedArrayBuffer`Â  è¢«æ‰©å±•ä»¥è·å–å…è®¸å°±åœ°å¢é•¿çš„é¢å¤–æœ€å¤§é•¿åº¦ã€‚

```js
let rab = new ArrayBuffer(1024, { maxByteLength: 1024 ** 2 });
// 0 offset, auto length
let U32a = new Uint32Array(rab);
assert(U32a.length === 256); // (1024 - 0) / 4
rab.resize(1024 * 2);
assert(U32a.length === 512); // (2048 - 0) / 4

// Non-0 offset, auto length
let U32b = new Uint32Array(rab, 256);
assert(U32b.length === 448); // (2048 - 256) / 4
rab.resize(1024);
assert(U32b.length === 192); // (1024 - 256) / 4

// Non-0 offset, fixed length
let U32c = new Uint32Array(rab, 128, 4);
assert(U32c.length === 4);
rab.resize(1024 * 2);
assert(U32c.length === 4);

// If a resize makes any accessible part of a TA OOB, the TA acts like
// it's been detached.
rab.resize(256);
assertThrows(() => U32b[0]);
assert(U32b.length === 0);
rab.resize(132);
// U32c can address rab[128] to rab[144]. Being partially OOB still makes
// it act like it's been detached.
assertThrows(() => U32c[0]);
assert(U32c.length === 0);
// Resizing the underlying buffer can bring a TA back into bounds.
// New memory is zeroed.
rab.resize(1024);
assert(U32b[0] === 0);
assert(U32b.length === 192);
```

## æ•°ç»„åˆ†ç»„

æ•°ç»„åˆ†ç»„æ˜¯ä¸€ç§æå…¶å¸¸è§çš„æ“ä½œï¼Œæœ€å¥½çš„ä¾‹å­æ˜¯ SQL çš„ Â `GROUP BY`Â  å­å¥å’Œ MapReduce ç¼–ç¨‹ï¼ˆæ›´å¥½åœ°è®¤ä¸ºæ˜¯ map-group-reduceï¼‰ã€‚å°†ç±»ä¼¼æ•°æ®ç»„åˆæˆç»„çš„èƒ½åŠ›ä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿè®¡ç®—æ›´é«˜é˜¶çš„æ•°æ®é›†ï¼Œä¾‹å¦‚ç¾¤ç»„çš„å¹³å‡å¹´é¾„æˆ–ç½‘é¡µçš„æ¯æ—¥ LCP å€¼ã€‚

æä¾›äº†ä¸¤ç§æ–¹æ³•ï¼šÂ `Object.groupBy`Â  å’Œ Â `Map.groupBy`Â ã€‚ç¬¬ä¸€ä¸ªè¿”å›ä¸€ä¸ªç©ºåŸå‹å¯¹è±¡ï¼Œå®ƒå…è®¸ç¬¦åˆäººä½“å·¥ç¨‹å­¦çš„è§£æ„å¹¶é˜²æ­¢ä¸å…¨å±€å¯¹è±¡å±æ€§å‘ç”Ÿæ„å¤–å†²çªã€‚ç¬¬äºŒä¸ªè¿”å›ä¸€ä¸ªå¸¸è§„ Â `Map`Â  å®ä¾‹ï¼Œå®ƒå…è®¸å¯¹å¤æ‚é”®ç±»å‹è¿›è¡Œåˆ†ç»„ï¼ˆæƒ³è±¡ä¸€ä¸‹å¤åˆé”®æˆ–å…ƒç»„ï¼‰ã€‚

**ç¤ºä¾‹ï¼š**

```js
const array = [1, 2, 3, 4, 5];

// `Object.groupBy` é€šè¿‡ä»»æ„é”®å¯¹é¡¹ç›®è¿›è¡Œåˆ†ç»„
// åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬æŒ‰å¶æ•°/å¥‡æ•°é”®è¿›è¡Œåˆ†ç»„
Object.groupBy(array, (num, index) => {
    return num % 2 === 0 ? "even" : "odd";
});
// =>  { odd: [1, 3, 5], even: [2, 4] }

// `Map.groupBy` è¿”å›Mapä¸­çš„é¡¹ï¼Œç”¨äºä½¿ç”¨å¯¹è±¡é”®è¿›è¡Œåˆ†ç»„
const odd = { odd: true };
const even = { even: true };
Map.groupBy(array, (num, index) => {
    return num % 2 === 0 ? even : odd;
});
// =>  Map { {odd: true}: [1, 3, 5], {even: true}: [2, 4] }
```

## `Promise.withResolvers`

`Promise.withResolvers` çš„ç›®çš„æ˜¯ç®€åŒ–ä» Â `Promise`Â  ä¸­æå– Â `resolve`Â  å’Œ Â `reject`ã€‚

```js
// ============= ææ¡ˆå‰ =============
let resolve = () => {};
let reject = () => {};

function request(type, message) {
    if (socket) {
        const promise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        socket.emit(type, message);
        return promise;
    }

    return Promise.reject(new Error("Socket unavailable"));
}

socket.on("response", (response) => {
    if (response.status === 200) {
        resolve(response);
    } else {
        reject(new Error(response));
    }
});

socket.on("error", (err) => {
    reject(err);
});
// ============= ææ¡ˆå =============

const { promise, resolve, reject } = Promise.withResolvers();

function request(type, message) {
    if (socket) {
        socket.emit(type, message);
    }

    return reject(new Error("Socket unavailable"));
}

socket.on("response", (response) => {
    if (response.status === 200) {
        resolve(response);
    } else {
        reject(new Error(response));
    }
});

socket.on("error", (err) => {
    reject(err);
});
```

## `ArrayBuffer.prototype.transfer`

`ArrayBuffer`Â  å¯ä»¥é€šè¿‡ HTML çš„åºåˆ—åŒ–ç®—æ³•è¿›è¡Œä¼ è¾“å’Œåˆ†ç¦»ï¼Œä½†æ˜¯ç¼ºå°‘ç”¨äºç›¸åŒè¡¨è¾¾èƒ½åŠ›çš„ç¼–ç¨‹ JS APIã€‚ç¼–ç¨‹ API å¯¹äºç¼–ç¨‹æ¨¡å¼å¾ˆæœ‰ç”¨ï¼Œä¾‹å¦‚è½¬ç§» Â `ArrayBuffer`Â  çš„æ‰€æœ‰æƒã€ä¼˜åŒ–é‡æ–°åˆ†é…ï¼ˆå³ Â `realloc`Â  è¯­ä¹‰ï¼‰ä»¥åŠå°†å¯è°ƒæ•´å¤§å°çš„ Â `ArrayBuffer`Â  å›ºå®šä¸ºå›ºå®šå¤§å°ã€‚é•¿åº¦çš„ã€‚è¯¥ææ¡ˆé€šè¿‡å‘ Â `ArrayBuffer.prototype`Â  æ·»åŠ æ–°æ–¹æ³•æ¥å¡«å……è¿™ç§è¡¨è¾¾èƒ½åŠ›ã€‚

è¯¥ææ¡ˆæ˜¯ä»[å¯è°ƒæ•´å¤§å°çš„ç¼“å†²åŒº](https://github.com/tc39/proposal-resizablearraybuffer/issues/113)ææ¡ˆä¸­è¡ç”Ÿå‡ºæ¥çš„ã€‚åœ¨æ¨å‡ºæ—¶ï¼Œå¯è°ƒæ•´å¤§å°çš„ç¼“å†²åŒºå¤„äºç¬¬ 3 é˜¶æ®µï¼Œè¯¥ææ¡ˆå·²é™çº§åˆ°ç¬¬ 2 é˜¶æ®µã€‚

### åº”ç”¨ç¨‹åºç¼–ç¨‹æ¥å£

```js
class ArrayBuffer {
  // ... existing stuff

  // Returns a new ArrayBuffer with the same byte content
  // as this buffer for [0, min(this.byteLength, newByteLength)],
  // then detaches this buffer.
  //
  // The maximum byte length and thus the resizability of this buffer
  // is preserved in the new ArrayBuffer.
  //
  // Any new memory is zeroed.
  //
  // If newByteLength is undefined, it is set to this.bytelength.
  //
  // Designed to be implementable as a copy-free move or a realloc.
  //
  // Throws a RangeError unless all of the following are satisfied:
  // - 0 <= newByteLength
  // - If this buffer is resizable, newByteLength <= this.maxByteLength
  transfer(newByteLength);

  // Like transfer, except always returns a non-resizable ArrayBuffer.
  transferToFixedLength(newByteLength);

  // Returns whether this ArrayBuffer is detached.
  get detached();
}
```

## å‚è€ƒå†…å®¹

-   [tc39/proposal-is-usv-string ææ¡ˆ](https://github.com/tc39/proposal-is-usv-string)
-   [tc39/proposal-atomics-wait-async ææ¡ˆ](https://github.com/tc39/proposal-atomics-wait-async)
-   [tc39/proposal-regexp-v-flag ææ¡ˆ](https://github.com/tc39/proposal-regexp-v-flag)
-   [tc39/proposal-resizablearraybuffer ææ¡ˆ](https://github.com/tc39/proposal-resizablearraybuffer)
-   [tc39/proposal-array-grouping ææ¡ˆ](https://github.com/tc39/proposal-array-grouping)
-   [tc39/proposal-promise-with-resolvers](https://github.com/tc39/proposal-promise-with-resolvers)
-   [tc39/proposal-arraybuffer-transfer ææ¡ˆ](https://github.com/tc39/proposal-arraybuffer-transfer)
