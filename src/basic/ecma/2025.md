# ECMA 2025(ES16) 新特性

随着 ECMAScript 的不断迭代，2025 年的版本（通常被称为 **ECMA2025**）带来了许多新特性。
这些改进不仅让 JavaScript 写起来更简洁，还提升了性能和可维护性。本文将带你快速浏览这些即将在 ECMA2025 中标准化的功能。

## 1. Iterator Helpers / 新的迭代器方法

ECMA2025 为迭代器（`Iterator`）引入了一批常用的工具方法。
这些方法与 `Array.prototype` 上的 `map`、`filter`、`take` 等类似，但直接运行在迭代器上，避免了额外的数组创建，适合处理潜在无限或大规模的数据源。

**示例代码：**

```js
// 使用 iterator.map 和 iterator.filter
function* numbers() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}

const iter = numbers()
    .map((x) => x * 2)
    .filter((x) => x > 4);

console.log([...iter]); // [6, 8]

// take 方法：取前 n 个元素
const iter2 = numbers().take(2);
console.log([...iter2]); // [1, 2]
```

## 2. Set 方法增强

`Set` 新增了一些实用的方法，比如集合运算（交集、并集、差集、对称差集）。这让处理集合数据变得更直观。

**示例代码：**

```js
const a = new Set([1, 2, 3]);
const b = new Set([3, 4, 5]);

console.log(a.intersection(b)); // Set { 3 }
console.log(a.union(b)); // Set { 1, 2, 3, 4, 5 }
console.log(a.difference(b)); // Set { 1, 2 }
console.log(a.symmetricDifference(b)); // Set { 1, 2, 4, 5 }
```

## 3. 正则表达式 —— 增强特性

ECMA2025 在正则表达式方面的主要增强包括：

-   **重复命名捕获组（Duplicate Named Capturing Groups）**、
-   **子表达式级别的标记（Pattern / Subexpression Modifiers）**，
-   标准化的 **`RegExp.escape()`**。

### 重复命名捕获组（Duplicate Named Capturing Groups）

```js
// 两种日期格式都使用相同的命名捕获组 name
const re =
    /(?<day>\d{2})\/(?<month>\d{2})\/(?<year>\d{4})|(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
console.log("21/12/2023".match(re).groups.day); // '21'
console.log("2023-12-21".match(re).groups.day); // '21'
```

该提案允许在不同的 `|` 分支中重复使用同名捕获组（这样在任意一次匹配中只有一组会生效），从而简化匹配多种格式但结构相似的文本。

### 子表达式标记（Pattern / Subexpression Modifiers）

```js
// 在子表达式中启用或禁用 i/m/s 等标志
const re1 = /^[a-z](?-i:[a-z])$/i;
console.log(re1.test("ab")); // true
console.log(re1.test("Ab")); // true
console.log(re1.test("aB")); // false

const re2 = /^(?i:[a-z])[a-z]$/;
console.log(re2.test("ab")); // true
console.log(re2.test("Ab")); // true
console.log(re2.test("aB")); // false
```

子表达式标记允许我们只对正则的某一部分应用标志（如忽略大小写等），这在编写复杂模式或用在配置/语法高亮等无法执行代码的场景时非常有用。

### `RegExp.escape()`

```js
console.log(RegExp.escape("(*)")); // "\(\*\)"
// 把用户输入安全地作为字面文本使用
const safe = RegExp.escape(userInput);
const re = new RegExp(safe);
```

`RegExp.escape` 提供了一个标准化的方式来转义字符串中的正则元字符，避免手写转义出错。

## 4. Promise.try

`Promise.try` 提供了一种更简洁的方式来将同步/异步代码统一到 `Promise` 中，避免手动写 `new Promise`。

**示例代码：**

```js
Promise.try(() => {
    if (Math.random() > 0.5) throw new Error("Oops");
    return "success";
})
    .then(console.log)
    .catch(console.error);
```

## 5. Float16Array

ECMA2025 引入了新的 `Float16Array` 类型，专门用于半精度浮点数。这在 WebGL、机器学习等领域尤其有用。

**示例代码：**

```js
const arr = new Float16Array([1.1, 2.2, 3.3]);
console.log(arr[0]); // 1.099609375 (半精度存储导致的近似值)
```

## 6. Import Attributes

ECMA2025 标准化了 `import` 属性，用于指定导入模块的类型，特别是在 JSON、CSS 等非 JS 模块导入场景下。

**示例代码：**

```js
import config from "./config.json" with { type: "json" };
console.log(config);
```

## 7. 显式资源管理（Explicit Resource Management）

通过 `using` 语法，可以在作用域结束时自动调用资源的释放逻辑，避免忘记清理资源。

**示例代码：**

```js
class FileHandler {
  constructor(name) {
    this.name = name;
  }
  close() {
    console.log(`${this.name} closed`);
  }
  [Symbol.dispose]() {
    this.close();
  }
}

{
  using file = new FileHandler("data.txt");
  console.log("Working with file...");
}
// 输出:
// Working with file...
// data.txt closed
```

## 总结

ECMA2025 带来的这些新特性涵盖了 **迭代器处理、集合运算、正则增强、Promise 简化、数值类型扩展、模块导入属性以及资源管理** 等方面。它们将进一步提升 JavaScript 在大规模应用、性能优化以及跨领域应用（如数据科学、WebGL）中的表现。

## 参考

-   [Iterator Helpers 提案](https://github.com/tc39/proposal-iterator-helpers)
-   [Set Methods 提案](https://github.com/tc39/proposal-set-methods)
-   [RegExp v flag 提案](https://github.com/tc39/proposal-regexp-v-flag)
-   [Promise.try 提案](https://github.com/tc39/proposal-promise-try)
-   [Float16Array 提案](https://github.com/tc39/proposal-float16array)
-   [Import Attributes 提案](https://github.com/tc39/proposal-import-attributes)
-   [Explicit Resource Management 提案](https://github.com/tc39/proposal-explicit-resource-management)
